package types

import (
	"bytes"
	"crypto/rand"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"strings"
	"testing"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/rlp"
	"github.com/ethereum/go-ethereum/trie"
)

func toHexStr(b []byte) string {
	return fmt.Sprintf("0x%x", b)
}

type _DerivableList interface {
	Len() int
	GetRlp(i int) []byte
}

// same logic as DeriveSha(...)
func _DeriveSha(list _DerivableList) (*trie.Trie, common.Hash) {
	keybuf := new(bytes.Buffer)
	trie := new(trie.Trie)
	for i := 0; i < list.Len(); i++ {
		keybuf.Reset()
		rlp.Encode(keybuf, uint(i))
		trie.Update(keybuf.Bytes(), list.GetRlp(i))
	}
	return trie, trie.Hash()
}

type RawRLP []byte

func (raw RawRLP) EncodeRLP(w io.Writer) error {
	w.Write(raw)
	return nil
}

type MemDB struct {
	keys   [][]byte
	values []RawRLP
}

func (db *MemDB) Put(key []byte, value []byte) error {
	db.keys = append(db.keys, key)
	db.values = append(db.values, RawRLP(value))
	return nil
}

// Delete removes the key from the key-value data store.
func (db *MemDB) Delete(key []byte) error {
	panic("Delete")
}

func (db *MemDB) Has(key []byte) (bool, error) {
	panic("Has")
}

// Get retrieves the given key if it's present in the key-value data store.
func (db *MemDB) Get(key []byte) ([]byte, error) {
	for i, dbkey := range db.keys {
		if bytes.Compare(dbkey, key) == 0 {
			return []byte(db.values[i]), nil
		}
	}
	panic("not found")
}

func (db *MemDB) ToProof() string {
	b, _ := rlp.EncodeToBytes(db.values)
	return common.Bytes2Hex(b)
}

// copy from trie.keybytesToHex
func keybytesToHex(str []byte) []byte {
	l := len(str)*2 + 1
	var nibbles = make([]byte, l)
	for i, b := range str {
		nibbles[i*2] = b / 16
		nibbles[i*2+1] = b % 16
	}
	nibbles[l-1] = 16
	return nibbles
}

type Inputs struct {
	RootHash string `json:"rootHash"`
	Keys     string `json:"keys"`
	Proof    string `json:"proof"`
}

type TestCase struct {
	Result bool   `json:"result"`
	Return string `json:"return"`
	Inputs Inputs `json:"inputs"`
}

func TestReceiptMPT(t *testing.T) {
	testcases := make([]TestCase, 0, 11111)
	testcases = append(testcases, randomCases(1)...)
	//testcases = append(testcases, randomCases(10)...)
	//testcases = append(testcases, randomCases(100)...)
	//testcases = append(testcases, randomCases(1000)...)
	//testcases = append(testcases, randomCases(10000)...)

	tj, _ := json.Marshal(testcases)
	err := ioutil.WriteFile("/tmp/testcases.json", tj, 0666)
	if err != nil {
		panic("write error")
	}
}

func randomCases(elemLen int) []TestCase {
	cases := make([]TestCase, 0, elemLen)
	rs := make(Receipts, 0, elemLen)
	for i := 0; i < elemLen; i++ {
		var rh [32]byte
		rand.Read(rh[:])
		r := NewReceipt(rh[:], i&1 == 0, uint64(i))
		rs = append(rs, r)
	}
	tree, rootHash := _DeriveSha(rs)
	for i := 0; i < elemLen; i++ {
		b, _ := rlp.EncodeToBytes(uint(i))
		var db MemDB
		tree.Prove(b, 0, &db) // generate proof data in db.values
		ret, err := trie.VerifyProof(rootHash, b, &db)
		cases = append(cases, TestCase{
			Result: err == nil,
			Return: toHexStr(ret),
			Inputs: Inputs{
				RootHash: rootHash.String(),
				Keys:     toHexStr(keybytesToHex(b)),
				Proof:    db.ToProof(),
			},
		})
	}
	return cases
}

type testEntry struct {
	key string
	val string
}

var testData = []testEntry {
	{
		key: "80",
		val: "f901640183011e35b9010000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000800000000000000000000040000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000f85af8589496d5d8bc539694e5fa1ec0dab0e6327ca9e680f9e1a05a978f4723b249ccf79cd7a658a8601ce1ff8b89fc770251a6be35216351ce32a0000000000000000000000000000000000000000000000000000000000036fe20",
	},
	{
		key: "01",
		val: "f90109018301723db9010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c0",
	},
	{
		key: "02",
		val: "f903030183021be4b9010000000000000800000000000000000000040000000800000000000000000000000000000000000000000000000000000020000000000000000000020000200000000000000000000000000008000000000020000000000000000000000000000020000000000000000000000400000000000000000000000000000010000000000000000000000000000000000000000000000000000000000020000000000000020000000040020000000000000000000000000000000000080000000000000000000802010000000000000000002000000000000000000000000000000008001010000000000000000020000000000000000000000000000000000000000000f901f8f89b94f3293bcba4a015df909769088c971d72cacd4bb4f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa000000000000000000000000077cbcc0e29e10f1eea24e0d109aab26c5b2abd88a00000000000000000000000005e1d976bd4cf97bb593e6bc88ba50b54b664b09ca00000000000000000000000000000000000000000000000000de0b6b3a7640000f89b94f3293bcba4a015df909769088c971d72cacd4bb4f863a08c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925a000000000000000000000000077cbcc0e29e10f1eea24e0d109aab26c5b2abd88a00000000000000000000000005e1d976bd4cf97bb593e6bc88ba50b54b664b09ca00000000000000000000000000000000000000000000000000000000000000000f8bc945e1d976bd4cf97bb593e6bc88ba50b54b664b09cf863a04c6ab40ee4cfa212a441d32ee2897945b4a52461284f9369e23fdf8faa6cdd69a0000000000000000000000000f3293bcba4a015df909769088c971d72cacd4bb4a000000000000000000000000077cbcc0e29e10f1eea24e0d109aab26c5b2abd88b8400000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000077cbcc0e29e10f1eea24e0d109aab26c5b2abd88",
	},
	{
		key: "03",
		val: "f901090183028654b9010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c0",
	},
	{
		key: "04",
		val: "f90109018302d85cb9010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c0",
	},
}


var (
	testHash = "0xb31e2a142b4f18e5be431b6367dc81874a2af75438072e2ae263f865e9006379"
	testKey = "0x02"
	testProof = "0xf903f3f851a08cba5d5c8e62286756d9afdd2e8bb794459261a8c6cf1f1f29eff526e2ff9b2e80808080808080a08abd06772847790a9f2cced44a24b5b8ebec0db0785321922a01b5fae527b0108080808080808080f89180a01e6d742f33659bb9dedc27938064c01001424102c894eaf3f1d3031bfed93881a0113b9ab4b7381595fd545ec3173e5b3c3a6d0d3bd34337985910c02a80b4f96da006e8f82bb10c73265489985e3e5812451a8cab47327b6643ecc535ab110be5d8a07c2c9e42773d2d6d3528473028b83f3e67b194dd94172d4b08efaa8f93bdea8a808080808080808080808080f9030a20b90306f903030183021be4b9010000000000000800000000000000000000040000000800000000000000000000000000000000000000000000000000000020000000000000000000020000200000000000000000000000000008000000000020000000000000000000000000000020000000000000000000000400000000000000000000000000000010000000000000000000000000000000000000000000000000000000000020000000000000020000000040020000000000000000000000000000000000080000000000000000000802010000000000000000002000000000000000000000000000000008001010000000000000000020000000000000000000000000000000000000000000f901f8f89b94f3293bcba4a015df909769088c971d72cacd4bb4f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa000000000000000000000000077cbcc0e29e10f1eea24e0d109aab26c5b2abd88a00000000000000000000000005e1d976bd4cf97bb593e6bc88ba50b54b664b09ca00000000000000000000000000000000000000000000000000de0b6b3a7640000f89b94f3293bcba4a015df909769088c971d72cacd4bb4f863a08c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925a000000000000000000000000077cbcc0e29e10f1eea24e0d109aab26c5b2abd88a00000000000000000000000005e1d976bd4cf97bb593e6bc88ba50b54b664b09ca00000000000000000000000000000000000000000000000000000000000000000f8bc945e1d976bd4cf97bb593e6bc88ba50b54b664b09cf863a04c6ab40ee4cfa212a441d32ee2897945b4a52461284f9369e23fdf8faa6cdd69a0000000000000000000000000f3293bcba4a015df909769088c971d72cacd4bb4a000000000000000000000000077cbcc0e29e10f1eea24e0d109aab26c5b2abd88b8400000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000077cbcc0e29e10f1eea24e0d109aab26c5b2abd88"
)


func TestMerkleProof(t *testing.T) {
	tr := new(trie.Trie)

	for _, entry := range testData {
		tr.Update(common.Hex2Bytes(entry.key), common.Hex2Bytes(entry.val))
	}

	var db MemDB
	b, _ := rlp.EncodeToBytes(uint(2))
	tr.Prove(b, 0, &db)

	_, err := trie.VerifyProof(tr.Hash(), b, &db)
	if err != nil {
		t.Error(err)
	}

	root := common.HexToHash(testHash)
	key := common.Hex2Bytes(testKey)
	exp := common.Bytes2Hex(b)

	if strings.TrimPrefix(testProof, "0x") != strings.TrimPrefix(db.ToProof(), "0x") {
		t.Errorf("proof data not equal")
	}
	if root != tr.Hash() {
		t.Errorf("root not equal")
	}
	if strings.TrimPrefix(testKey, "0x") != common.Bytes2Hex(b) {
		t.Errorf("key not equal: %x/ %x", key, b)
	}

	_, err = trie.VerifyProof(root, b, &db)
	if err != nil {
		t.Errorf("verify error %v", err)
	}
}
